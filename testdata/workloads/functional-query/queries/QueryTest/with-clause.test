====
---- QUERY
# Basic test with a single with-clause view.
with t as (select int_col x, bigint_col y from functional.alltypestiny)
select count(x), count(y) from t
---- RESULTS
8,8
---- TYPES
BIGINT, BIGINT
====
---- QUERY
# Basic test with a single with-clause view that references a virtual view.
with t as (select abc x, xyz y from functional.complex_view)
select x, y from t order by y limit 10
---- RESULTS
2,'0'
2,'1'
---- TYPES
BIGINT, STRING
====
---- QUERY
# Basic tests with a single with-clause view with column labels.
with t(c1, c2) as (select int_col, bigint_col y from functional.alltypestiny)
select * from t limit 1
---- RESULTS
0,0
---- TYPES
INT, BIGINT
---- LABELS
C1, C2
====
---- QUERY
with t(c1) as (select int_col, bigint_col from functional.alltypestiny)
select * from t limit 1
---- RESULTS
0,0
---- TYPES
INT, BIGINT
---- LABELS
C1, BIGINT_COL
====
---- QUERY
with t(c1, c2) as (select int_col from functional.alltypestiny)
select * from t limit 1
---- CATCH
AnalysisException: WITH-clause view 't' returns 1 columns, but 2 labels were specified.
====
---- QUERY
# Multiple views in with-clause. Only one view is used.
with t1 as (select int_col x, bigint_col y from functional.alltypestiny),
t2 as (select 1 x, 10 y), t3 as (values(2 x, 20 y), (3, 30))
select x, y from t2
---- RESULTS
1,10
---- TYPES
TINYINT, TINYINT
====
---- QUERY
# Multiple views in with-clause. All views are used in a union.
with t1 as (select int_col x, bigint_col y from functional.alltypestiny),
t2 as (select 1 x, 10 y), t3 as (values(2 x, 20 y), (3, 30))
select * from t1 union all select * from t2 union all (select * from t3) order by x limit 20
---- RESULTS
0,0
0,0
0,0
0,0
1,10
1,10
1,10
1,10
1,10
2,20
3,30
---- TYPES
INT, BIGINT
====
---- QUERY
with t1(c1, c2) as (select int_col x, bigint_col y from functional.alltypestiny),
t2(c3, c4) as (select 1 x, 10 y)
select * from t1 limit 1 union all select * from t2 limit 1
---- RESULTS
0,0
1,10
---- TYPES
INT, BIGINT
---- LABELS
C1, C2
====
---- QUERY
# Multiple views in with-clause. All views are used in a join.
with t1 as (select int_col x, bigint_col y from functional.alltypes limit 2),
t2 as (select int_col x, bigint_col y from functional.alltypestiny limit 2),
t3 as (select int_col x, bigint_col y from functional.alltypessmall limit 2)
select * from t1, t2, t3 where t1.x = t2.x and t2.x = t3.x
---- RESULTS
0,0,0,0,0,0
1,10,1,10,1,10
---- TYPES
INT, BIGINT, INT, BIGINT, INT, BIGINT
====
---- QUERY
# Self-join of with-clause table to make sure the join op is properly set
# in the cloned inline-view instances.
with t as (select int_col x, bigint_col y from functional.alltypestiny order by id limit 2)
select * from t t1 left outer join t t2 on t1.y = t2.x full outer join t t3 on t2.y = t3.x
order by t1.x limit 10
---- RESULTS
0,0,0,0,0,0
1,10,NULL,NULL,NULL,NULL
NULL,NULL,NULL,NULL,1,10
---- TYPES
INT, BIGINT, INT, BIGINT, INT, BIGINT
====
---- QUERY
# Multiple with clauses. One for the UnionStmt and one for each union operand.
with t1 as (values('a', 'b'))
(with t2 as (values('c', 'd')) select * from t2) union all
(with t3 as (values('e', 'f')) select * from t3)
---- RESULTS
'e','f'
'c','d'
---- TYPES
STRING, STRING
====
---- QUERY
# With clause containing an order by element that should be cloned properly.
with t1 as (select tinyint_col, count(*) from alltypesagg group by 1
order by 1 desc nulls last limit 10) select * from t1;
---- RESULTS
9,1000
8,1000
7,1000
6,1000
5,1000
4,1000
3,1000
2,1000
1,1000
NULL,2000
---- TYPES
TINYINT, BIGINT
====
---- QUERY
# IMPALA-1357: Analysis of WithClause pollutes global state
select 1 from (
  with w as (
    select 1 from alltypestiny
    where exists (select 1 from alltypestiny))
  select 1 from w) tt
---- RESULTS
1
1
1
1
1
1
1
1
---- TYPES
TINYINT
====
---- QUERY
# IMPALA-2414: Test basic correlated WITH clause view.
select pos from functional.allcomplextypes t inner join
  (with w as (select pos from t.int_array_col)
   select pos from w) v
on v.pos = t.id
---- RESULTS
---- TYPES
BIGINT
====
---- QUERY
# IMPALA-2414: Test correlated WITH clause view nested in another WITH clause.
select c_custkey, o_orderkey from tpch_nested_parquet.customer c join
  (with w1 as (with w2 as (select o_orderkey from c.c_orders) select * from w2)
   select o_orderkey from w1) v
where c_custkey = 4
---- RESULTS
4,164711
4,385825
4,1192231
4,1226497
4,1590469
4,1755398
4,1944711
4,1953441
4,1978756
4,2459619
4,2765152
4,2986913
4,3251169
4,3421092
4,3683623
4,3951331
4,4320612
4,4960614
4,5453440
4,5612065
---- TYPES
BIGINT,BIGINT
====
---- QUERY
# IMPALA-2414: Test correlated WITH clause view nested in another WITH clause.
with w1 as (select c_custkey, o_orderkey from tpch_nested_parquet.customer c join
  (with w2 as (select o_orderkey from c.c_orders) select * from w2) v)
select * from w1
where c_custkey = 4
---- RESULTS
4,164711
4,385825
4,1192231
4,1226497
4,1590469
4,1755398
4,1944711
4,1953441
4,1978756
4,2459619
4,2765152
4,2986913
4,3251169
4,3421092
4,3683623
4,3951331
4,4320612
4,4960614
4,5453440
4,5612065
---- TYPES
BIGINT,BIGINT
====
---- QUERY
# IMPALA-2414: Test multiple correlated WITH clause views that are joined.
select pos from functional.allcomplextypes t inner join
  (with w1 as (select pos, item from t.int_array_col),
   w2 as (select key, value from t.map_map_col.value)
   select a1.*, m2.* from w1 a1, w1 a2, w2 m1, w2 m2) v on v.value = t.id
---- RESULTS
---- TYPES
BIGINT
====
